//
//
// MIT License
//
// Copyright (c) 2020 Stellacore Corporation.
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject
// to the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
// KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
// AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
// IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
//


#ifndef periDetail_INCL_
#define periDetail_INCL_


#include <array>
#include <cmath>
#include <numeric>


// utilities
namespace peri
{
	//! Use to indicate invalid data values
	constexpr double sNan{ std::numeric_limits<double>::quiet_NaN() };

	//! Invalid triplet
	constexpr std::array<double, 3u> sNull{ sNan, sNan, sNan };

	//! Classic square operation (value times itself)
	template <typename Type>
	inline
	Type
	sq
		( Type const & value
		)
	{
		return (value * value);
	}

	//! "Vector addition" for two std::array data types
	inline
	std::array<double, 3u>
	operator+
		( std::array<double, 3u> const & valuesA
		, std::array<double, 3u> const & valuesB
		)
	{
		return
			{ valuesA[0] + valuesB[0]
			, valuesA[1] + valuesB[1]
			, valuesA[2] + valuesB[2]
			};
	}

	//! "Vector 'subtraction'" for two std::array data types
	inline
	std::array<double, 3u>
	operator-
		( std::array<double, 3u> const & valuesA
		, std::array<double, 3u> const & valuesB
		)
	{
		return
			{ valuesA[0] - valuesB[0]
			, valuesA[1] - valuesB[1]
			, valuesA[2] - valuesB[2]
			};
	}

	//! Unitary negation
	inline
	std::array<double, 3u>
	operator-
		( std::array<double, 3u> const & values
		)
	{
		return
			{ -values[0]
			, -values[1]
			, -values[2]
			};
	}

	//! "scalar-Vector" multiplication for two std::array data types
	inline
	std::array<double, 3u>
	operator*
		( double const & scale
		, std::array<double, 3u> const & values
		)
	{
		return
			{ scale * values[0]
			, scale * values[1]
			, scale * values[2]
			};
	}

	//! Vector dot product of two arrays
	inline
	double
	dot
		( std::array<double, 3u> const & vecA
		, std::array<double, 3u> const & vecB
		)
	{
		return std::inner_product
			( vecA.begin(), vecA.end()
			, vecB.begin(), 0.
			);
		/*
		// C++17 syntax
		return std::inner_product
			( std::cbegin(vecA), std::cend(vecA)
			, std::cbegin(vecB), 0.
			);
		*/
	}

	/*! \brief Unitary direction associated with non-zero orig
	 *
	 * \note Specialzied for non-zero orig vector. There is no check
	 * for zero magnitude inputs.
	 *
	 */
	inline
	std::array<double, 3u>
	unit
		( std::array<double, 3u> const & orig
		)
	{
		double const mag{ std::sqrt(dot(orig, orig)) };
		return { (1./mag) * orig };
	}


} // [peri]

namespace peri
{
	/*! \brief Local vertical "up" unit direction at Lon/Par(Lat) location.
	 *
	 * Conventional definition with components interpreted as
	 * \arg [0] : component in equator positive toward lon=0, par=0
	 * \arg [1] : component dextrally orthogonal to [2],[0] components
	 * \arg [2] : component orthogonal to equator, positive to North pole
	 */
	inline
	XYZ
	upFromLpa
		( LPA const & lpa //!< Only Lon,Par are used: Alt is ignored
		)
	{
		double const & lon = lpa[0];
		double const & par = lpa[1];
		return XYZ
			{ std::cos(par) * std::cos(lon)
			, std::cos(par) * std::sin(lon)
			, std::sin(par)
			};
	}


	/*! \brief Container for parameters describing oblate ellipsoidal shape.
	 *
	 * Represents an oblate spheroid of revolution generated by an ellipse
	 * rotated about its minor axis.
	 *
	 * Internal representation involves the semi-major axis, theRadA and
	 * semi-minor axis, theRadB assuming (theRadB <= theRadA). Interpretively
	 * theRadA is the "equatorial radius" and theRadB is the "polar radius".
	 * (The term "radius" is used as equivalent to "semi-axis").
	 *
	 * For geodetic applications, typical usage is to create an instance
	 * from equatorial radius and inverse (first) flattening factor via:
	 * \arg fromMajorInvFlat() - Create shape from common geodetic values
	 *
	 * \note There is nothing to prevent constructing instances with polar
	 * radius larger than equatorial one (i.e. a prolate ellipsoid) or by
	 * providing an negative inverse flattening factor. However, doing so
	 * is inconsistent with basic geodesy use-cases.
	 *
	 * Several data members provide values for derived parameter including:
	 * 
	 * Characteristic size:
	 * \arg #theLambda - The geometric mean of the two radii
	 *
	 * Shape coefficients useful in math expressions (ref doc/PerideticMath):
	 * \arg #theMus - The squared radii values by index
	 *
	 * Data normalization:
	 * \arg normalizedShape() - Conforming shape with unit characteristic size
	 */
	struct Shape
	{
		//! Equatorial radius
		double const theRadA{ sNan };

		//! Polar radius
		double const theRadB{ sNan };

		//! Characteristic length (geometric mean: sqrt(theRadA*theRadB))
		double const theLambda{ sNan };

		//! Coefficients describing geometric shape (i.e. {a^2, a^2, b^2})
		std::array<double, 3u> const theMus{ sNan, sNan, sNan };

	private:

		//! Value construction
		inline
		explicit
		Shape
			( double const & radA
				//!< Equatorial semi-axis magnitude
			, double const & radB
				//!< Polar semi-axis magnitude
			)
			: theRadA{ radA }
			, theRadB{ radB }
			, theLambda{ std::sqrt(theRadA * theRadB) }
			, theMus{ sq(theRadA), sq(theRadA), sq(theRadB) }
		{ }

	public:

		//! Create an instance using the semi-major axis and inverse-Flattening
		static
		inline
		Shape
		fromMajorInvFlat
			( double const & equatorialRadius
				//!< Equatorial (semi-major) radius: for Earth~=6.378e6
			, double const & invFlatFactor
				//!< Inverse (first) flattening factor (aka 1/f): for Earth~=298
			)
		{
			double const & aa = equatorialRadius;
			double const ff{ 1. / invFlatFactor };
			double const bb{ (1.-ff) * aa };
			return Shape(aa, bb);
		}

		//! A null instance (nan data member values)
		Shape
			() = default;

		//! A shape conformal to this one but with unit characteristic length.
		inline
		Shape
		normalizedShape
			() const
		{
			double const normPerOrig{ 1. / theLambda };
			return Shape(normPerOrig*theRadA, normPerOrig*theRadB);
		}

	}; // Shape


	/*! \brief Merit function to evaluate altitude scaling closure.
	 *
	 * Provides evaluation of ellipsoidal constraint function and
	 * its derivatives (with respect to 'sigma' scale parameter).
	 */
	struct ShapeClosure
	{
		//! Parameters describing the underlying shape.
		Shape theShape{};

		//! Value construction.
		inline
		explicit
		ShapeClosure
			( Shape const & shape
			)
			: theShape{ shape }
		{
		}

		//! Default creates a null instance (member values are NaN)
		ShapeClosure
			() = default;

		/*! \brief Ellipsoid constraint function and derivative values.
		 *
		 * Elements are:
		 * \arg [0]: Function value - ellipsoid "misclosure"
		 * \arg [1]: First derivative (with respect to sigma)
		 *
		 */
		 // * \arg [2]: Second derivative (with respect to sigma)
		inline
		std::array<double, 2u>
		funcDerivs
			( double const & sigma
			, XYZ const & qVec
			) const
		{
			std::array<double, 2u> fdfs;
			XYZ const invMuPlusSigmas
				{ 1. / (theShape.theMus[0] + sigma)
				, 1. / (theShape.theMus[1] + sigma)
				, 1. / (theShape.theMus[2] + sigma)
				};
			XYZ const muqSqs
				{ theShape.theMus[0] * sq(qVec[0])
				, theShape.theMus[1] * sq(qVec[1])
				, theShape.theMus[2] * sq(qVec[2])
				};
			// function value - for ellipsoid condition equation
			XYZ terms
				{ muqSqs[0] * sq(invMuPlusSigmas[0])
				, muqSqs[1] * sq(invMuPlusSigmas[1])
				, muqSqs[2] * sq(invMuPlusSigmas[2])
				};
			fdfs[0] = (terms[0] + terms[1] + terms[2]) - 1.;
			// first derivative - for ellipsoid condition equation
			terms[0] *= invMuPlusSigmas[0];
			terms[1] *= invMuPlusSigmas[1];
			terms[2] *= invMuPlusSigmas[2];
			fdfs[1] = -2.*(terms[0] + terms[1] + terms[2]);
			/*
			// second derivative - for ellipsoid condition equation
			terms[0] *= invMuPlusSigmas[0];
			terms[1] *= invMuPlusSigmas[1];
			terms[2] *= invMuPlusSigmas[2];
			fdfs[2] = 6.*(terms[0] + terms[1] + terms[2]);
			*/
			return fdfs;
		}

	}; // ShapeClosure


	/*! \brief Math description of ellipsoid surface (as a scalar field)
	 *
	 * Has members:
	 * \arg theShapeOrig - Shape parameters in orig units
	 * \arg theShapeNorm - Shape parameters in normalized units
	 *
	 * Characteristic size (used for normalization and restoration):
	 * \arg lambda() - Characteristic size parameter (forward from theShapeOrig)
	 *
	 * Provides: Data normalization/restoration functions:
	 * \arg xyzNormFrom - normalized vector (components near 1 in magnitude)
	 * \arg xyzOrigFrom - restored vector (components in physical units [m])
	 *
	 * Evaluations using normalized shape include:
	 * \arg gradientAt() - Vector gradient of shape field
	 *                     (proportional to ellipsoid normal vector)
	 *
	 * Employed notation includes:
	 * \arg xVec - an arbitrary point in space ('orig' physical units)
	 * \arg sVec - a point on surface of ellipsoid ('orig' physical units)
	 * \arg qVec - normalized expression for xVec ('norm' units near 1)
	 * \arg rVec - normalized expression for sVec ('norm' units near 1)
	 */
	struct Ellipsoid
	{
		//! Original magnitude shape parameters
		Shape const theShapeOrig{};

		//! Normalized equivalent shape (1==theShapeNorm.theLambda())
		Shape const theShapeNorm{};

		//! A null instance
		Ellipsoid
			() = default;

		//! Value construction
		inline
		explicit
		Ellipsoid
			( Shape const & shapeOrig
			)
			: theShapeOrig{ shapeOrig }
			, theShapeNorm{ theShapeOrig.normalizedShape() }
		{ }

		//! Characteristic size (geometric mean of original shape semi-axes)
		inline
		double
		lambda
			() const
		{
			return theShapeOrig.theLambda;
		}

		//! Cartesian vector normalized to working dimensions
		inline
		XYZ
		xyzNormFrom
			( XYZ const & xVec
			) const
		{
			double const scl{ 1. / lambda() };
			return
				{ scl*xVec[0]
				, scl*xVec[1]
				, scl*xVec[2]
				};
		}

		//! Cartesian vector restored to original units
		inline
		XYZ
		xyzOrigFrom
			( XYZ const & xVec
			) const
		{
			double const scl{ lambda() };
			return
				{ scl*xVec[0]
				, scl*xVec[1]
				, scl*xVec[2]
				};
		}

		//! Algebraic (mis)closure relative to ellipsoid level surface
		inline
		XYZ
		gradientAt
			( XYZ const & rVec
				//!< A point **ON** ellipse (i.e. assumes 0==funcValueAt(rVec))
			) const
		{
			return
				{ 2. * rVec[0] / theShapeNorm.theMus[0]
				, 2. * rVec[1] / theShapeNorm.theMus[1]
				, 2. * rVec[2] / theShapeNorm.theMus[2]
				};
		}

	}; // Ellipsoid


	/*! \brief Provide geodetic transforms at Earth scale (units of [m])
	 *
	 * Represents spatial configuration of Earth ellipsoidal shape
	 * and the relevant geometry in vicinity of its surface.
	 *
	 * Methods include:
	 * \arg lpaForXyz() - Geodetic coordinates from Cartesian
	 * \arg xyzForLpa() - Cartesian coordinates from Geodetic
	 */
	struct EarthModel
	{

	private:

		//! Geometric representation of surface
		Ellipsoid const theEllip{};

		//! Mathematical level condition associated with surface
		ShapeClosure const theMeritFunc{};

		// rotation rate, etc...
		// double theOmega{};

	public:

		//! A null instance
		EarthModel
			() = default;

		//! Construct to match physical geometry description
		inline
		explicit
		EarthModel
			( Shape const & shape
			)
			: theEllip(shape)
			, theMeritFunc(theEllip.theShapeNorm)
		{ }

		//! Geodetic coordinates associated with Cartesian coordinates xVec
		inline
		LPA
		lpaForXyz
			( XYZ const & xVec
			) const
		{
			// find point on ellipsoid closest to world point at xVec
			XYZ const rVec{ rVecFor(xVec) };
			// extract LP(A=0.) for point on ellipsoid at rVec
			LPA const surfLPA{ lpaForSurfacePoint(rVec) };
			// compute altitude as directed distance from ellipsoid at rVec
			XYZ const grad{ theEllip.gradientAt(rVec) };
			XYZ const up{ unit(grad) };
			double const lambda{ theEllip.lambda() };
			double const alt{ dot((xVec - lambda*rVec), up) };
			// return value as combo of LP and A computed results
			return LPA{ surfLPA[0], surfLPA[1], alt };
		}

		//! Cartesian coordinates for geodetic location lpa
		inline
		XYZ
		xyzForLpa
			( LPA const & lpa
			) const
		{
			double const & alt = lpa[2];
			// determine vertical direction at LP location
			XYZ const up{ upFromLpa(lpa) };
			// compute scaling coefficient
			std::array<double, 3u> const & mus = theEllip.theShapeNorm.theMus;
			double const sumMuUpSq // positive since all mu values are positive
				{ mus[0]*sq(up[0])
				+ mus[1]*sq(up[1])
				+ mus[2]*sq(up[2])
				};
			double const scl{ theEllip.lambda() / std::sqrt(sumMuUpSq) };
			// compute Cartesian location as displacement along normal dir
			return
				{ (scl*mus[0] + alt) * up[0]
				, (scl*mus[1] + alt) * up[1]
				, (scl*mus[2] + alt) * up[2]
				};
		}

	private:

		//! A linearly refined improvement to altitude scale factor currSigma
		inline
		double
		nextSigmaFor
			( double const & currSigma
			, XYZ const & qVec
			) const
		{
			// evaluate function and derivatives at expansion point
			double const & s0 = currSigma;
			std::array<double, 2u> const fdfs
				{ theMeritFunc.funcDerivs(s0, qVec) };
			// linear upate
			double const num{ fdfs[0] };
			double const den{ fdfs[1] };
			double const nextSigma{ s0 - num/den };
			return nextSigma;
		}

		//! Initial estimate for sigma factor (based on sphere approximation)
		inline
		double
		sigmaSphericalApprox
			( XYZ const & qVec
			) const
		{
			double const qMag{ std::sqrt(dot(qVec, qVec)) };
			return (qMag - 1.);
		}

		//! Refined altitude scale factor at normalized point location qVec
		inline
		double
		sigmaFor
			( XYZ const & qVec
			) const
		{
			// linearized iteration
			double sigma{ sigmaSphericalApprox(qVec) };
			double currTestVal{ 1. + sigma };
			// Convergence is very quick within operational range
			// e.g. 2 or 3 often sufficient in optimal domain
			constexpr std::size_t nnMax{ 8u };
			for (std::size_t nn{0u} ; nn < nnMax ; ++nn)
			{
				sigma = nextSigmaFor(sigma, qVec);
				double const nextTestVal{ 1. + sigma };
				// Tolerance suitable for 64-bit double type
				constexpr double tolDiff{ 1.e-15 };
				if (std::abs(currTestVal - nextTestVal) < tolDiff)
				{
					break;
				}
				currTestVal = nextTestVal;
			}
			return sigma;
		}

		//! Normalized point, rVec, on ellipsoid surface nearest original, xVec
		inline
		XYZ
		rVecFor
			( XYZ const & xVec
			) const
		{
			XYZ const qVec{ theEllip.xyzNormFrom(xVec) };
			double const sigma{ sigmaFor(qVec) };
			std::array<double, 3u> const & mus = theEllip.theShapeNorm.theMus;
			return
				{ mus[0] * qVec[0] / (mus[0] + sigma)
				, mus[1] * qVec[1] / (mus[1] + sigma)
				, mus[2] * qVec[2] / (mus[2] + sigma)
				};
		}

		//! Geodetic (Lon/Par) angles for point on ellipsoid surface (0==Alt).
		inline
		LPA
		lpaForSurfacePoint
			( XYZ const & rVec
			) const
		{
			XYZ const grad{ theEllip.gradientAt(rVec) };
			// familiar notation
			double const & xx = grad[0];
			double const & yy = grad[1];
			double const & zz = grad[2];
			// radius of parallel circle
			double const hh{ std::sqrt(sq(xx) + sq(yy)) };
			// compute conventional lon/par angles
			double lon{ 0. };
			if (! (0. == hh)) // if small hh, somewhat random longitude
			{
				lon = std::atan2(yy, xx);
			}
			double const par{ std::atan2(zz, hh) };
			// on surface, alt is identically 0
			constexpr double alt{ 0. };
			return LPA{ lon, par, alt };
		}

	}; // EarthModel


} // [peri]


//! Static instances of Shapes commonly used in Geodesy
namespace peri // ::shape // nested namespace c++ 17
{
namespace shape
{
	/*! \brief Defining parameters for GRS80 ellipsoid.
	 *
	 * Note that the shape of the GRS80 ellipsoid is _defined_ in terms
	 * of the equatorial axis and the second order harmonic (J2). This
	 * means that the flattening factors are _derived_ quantities that
	 * need to be computed.
	 *
	 * Ref:
	 * \arg http://geoweb.mit.edu/~tah/12.221_2005/grs80_corr.pdf
	 * , 1/f = 298.257222101 // Significant figs to about 6um at pole
	 * \arg https://iag.dgfi.tum.de/media/archives/HB2000/part4/grs80_corr.htm
	 * , 1/f = 298.257222101 // Moritz is one of the accepted definitions
	 * \arg https://geodesy.noaa.gov/library/pdfs/NOAA_Manual_NOS_NGS_0005.pdf
	 * , 1/f = 298.25722210088 // Good to about 16-digits at pole
	 * \arg https://en.wikipedia.org/wiki/Geodetic_Reference_System_1980
	 * , 1/f = 298.257 222 100 882 711 243;
	 *
	 * Flattening factor needs about 11 decimal digits after the decimal
	 * point (so about 14 overall) to provide full 'double' type precision
	 * in computed polar radius.
	 *
	 * The values in (the above copy of) report by Moritz differs from the
	 * longer precision values by about 10[nm] at the pole.
	 *
	 */
	static Shape const sGRS80
		{ Shape::fromMajorInvFlat
			( 6378137.0 // set by definition
			, 298.257222100883 // this precision provides 16-digits at pole
			)
		};

	/*! \brief Defining parameters for WGS84 ellipsoid.
	 *
	 * The WGS84 ellipsoid shape uses _both_ the equatorial radius and
	 * the (first) flattening factor to _define_ its shape.
	 *
	 * Ref:
	 * \arg
	 * ftp://ftp.nga.mil/pub2/gandg/website/wgs84/NGA.STND.0036_1.0.0_WGS84.pdf
	 * (pg 3-4): a == 6378137.0 [m], 1/f == 298.257223563 [-].
	 * \arg https://earth-info.nga.mil/GandG/publications/tr8350.2/wgs84fin.pdf
	 * (pg 3-2) a == 6378137.0 [m], 1/f == 298.257223563 [-].
	 */
	 // * 		- GM == 3.986004418e+14 [m^3/s^2]
	 // * 		- omega == 7.292115 × 10−05 [rad/s]
	static Shape const sWGS84
		{ Shape::fromMajorInvFlat
			( 6378137.0 // set by definition
			, 298.257223563 // set by definition
			)
		};

} // [shape]
} // [peri::shape]


/*! \brief Static instances of commonly used EarthModels
 *
 * Static instances that are available to consuming code. Others
 * can be created simply by constructing a peri::Shape instance with
 * the desired size and shape values and then using that shape to
 * construct a peri::EarthModel for use with transformations.
 *
 * E.g.:
 * \code
 *	static peri::EarthModel const myEarthModel
		( peri::Shape::fromMajorInvFlat
 *			( myEquatorialRadius
 *			, myInverseFlattening
 *			)
 *		);
 * \endcode
 */
namespace peri // ::model // nested namespace c++ 17
{
namespace model
{
	//! \brief Earth model based on GRS80 ellipsoid
	static EarthModel const GRS80(shape::sGRS80);

	//! \brief Earth model based on WGS84 ellipsoid
	static EarthModel const WGS84(shape::sWGS84);

} // [model]
} // [peri::model]


// Definitions for functions
// #include "periDetail.inl"

#endif // periDetail_INCL_

